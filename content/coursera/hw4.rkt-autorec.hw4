
#lang racket

(provide (all-defined-out)) ;; so we can put tests in a second file

;; put your code below

(define x 3)
(define y ( + x 2))

(define cube1
  (lambda (x)
    (* x (* x x)))) ; x * x * x
(define cube2
  (lambda (x)
    (* x x x))) ; x * x * x
(define (cube3 x)
    (* x x x))

; Functions really do take n arguments, its not syntactic sugar like ML.;

; Write a function sequence that takes 3 arguments low, high, and stride, all assumed to be numbers.
; Further assume stride is positive. sequence produces a list of numbers from low to high (including
; low and possibly high) separated by stride and in sorted order.

(define (sequence low high stride)
  (if (<= (- high low) 0)
  null
  (cons low (sequence (+ low stride) high stride))))

(define (string-append-map xs suffix)
  (map (lambda (x) (string-append x suffix)) xs))

; list-nth-mod that takes a list xs and a number n. If the number is negative,
; terminate the computation with (error "list-nth-mod: negative number"). Else if the list is
; empty, terminate the computation with (error "list-nth-mod: empty list").
; Else return the ith element of the list where we count from zero and i is the remainder produced when dividing n by the
; listâ€™s length. Library functions length, remainder, car, and list-tail are all useful

; How variables are looked up in environments is a fundamental feature of a programming language.
; let ([b1 e1] [b2 e1] ...)

(define (list-nth-mod xs n)
  (cond [(< n 0)  (error "list-nth-mod: negative number")]
        [(null? xs) (error "list-nth-mod: empty list")]
        [#t (let* ([i (remainder n (length xs))]
                  [return_index (lambda (xss, index)
                                  (cond [(= i index) (car xss)]
                                        [#t (return_index (list-tail xss)) (+ index 1)]))])
              (return_index xs 0))]))

